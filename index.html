<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Look Ma, It's a Starlink API</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Mapbox GL JS CSS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.13.0/mapbox-gl.css" rel="stylesheet" />
    <style>
        /* Full height for html and body */
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        /* Map container */
        #map-container {
            position: relative;
            width: 100%;
            height: 80vh;
        }

        /* Map fills the container */
        #map {
            width: 100%;
            height: 100%;
        }

        /* Flex overlay container spans the width of the map;
           flight controls go to the left and menu to the right */
        .map-overlays {
            position: absolute;
            top: 10px;
            left: 0;
            right: 0;
            z-index: 1;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            /* So clicks pass through to map except on controls */
            padding: 0 10px;
        }

        /* Both control panels get pointer-events enabled */
        #flight-controls,
        #menu {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            font-family: sans-serif;
            border-radius: 3px;
        }

        /* Flight controls stay at left */
        #flight-controls {
            /* No extra styling needed for left side */
        }

        /* Menu container appears at right and stacks each group vertically */
        #menu {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 220px;
        }

        /* Mapbox example listing-group CSS – removed absolute positioning */
        .listing-group {
            font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
            font-weight: 600;
            background-color: #3386c0;
            padding: 10px;
            border-radius: 3px;
            color: #fff;
            max-width: 100%;
        }

        .listing-group input[type='checkbox'] {
            display: none;
        }

        .listing-group input[type='checkbox'] + label {
            background-color: #3386c0;
            display: block;
            cursor: pointer;
            padding: 10px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.25);
            text-transform: capitalize;
        }

        .listing-group input[type='checkbox'] + label:hover,
        .listing-group input[type='checkbox']:checked + label {
            background-color: #4ea0da;
        }

        .listing-group input[type='checkbox']:checked + label:before {
            content: '✔';
            margin-right: 5px;
        }

        .listing-group h4 {
            margin: 0 0 8px;
            font-size: 16px;
            font-weight: bold;
        }

        .listing-group a {
            color: white;
            display: block;
            padding: 5px 8px;
            margin-bottom: 4px;
            text-decoration: none;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .listing-group a:hover,
        .listing-group a.active {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>

<body>
    <div class="container-fluid p-0">
        <!-- Header using Bootstrap navbar -->
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <div class="container-fluid">
                <a class="navbar-brand">Edge Optimizer for Starlink and ViaSat - Fastah Inc.</a>
            </div>
        </nav>

        <!-- Map container -->
        <div id="map-container">
            <div id="map"></div>
            <!-- Overlays container using flex -->
            <div class="map-overlays">
                <!-- Flight Controls (left side) -->
                <div id="flight-controls">
                    <span>Fly Honolulu to Boston</span>
                    <button id="startFlight" class="btn btn-primary btn-sm">Start</button>
                    <button id="stopFlight" class="btn btn-secondary btn-sm">Stop</button>
                    <button id="resetFlight" class="btn btn-warning btn-sm">Reset</button>
                </div>
                <!-- Layer Controls (right side) -->
                <div id="menu">
                    <div class="listing-group" id="aws-group">
                        <input type="checkbox" id="aws-toggle" checked>
                        <label for="aws-toggle">AWS</label>
                        <div class="aws-children" style="padding-left: 10px; margin-top: 5px; display: flex; flex-direction: column; gap: 0;">
                            <div class="aws-child">
                                <input type="checkbox" id="aws-regions" checked>
                                <label for="aws-regions">Regions</label>
                            </div>
                            <div class="aws-child">
                                <input type="checkbox" id="aws-localzones" checked>
                                <label for="aws-localzones">Local Zones</label>
                            </div>
                            <div class="aws-child">
                                <input type="checkbox" id="aws-groundstations">
                                <label for="aws-groundstations">Ground Stations</label>
                            </div>
                            <div class="aws-child">
                                <input type="checkbox" id="aws-wavelengthzones">
                                <label for="aws-wavelengthzones">Wavelength Zones</label>
                            </div>
                        </div>
                    </div>
                    <div class="listing-group" id="azure-group">
                        <input type="checkbox" id="azure-toggle">
                        <label for="azure-toggle">Azure Regions</label>
                    </div>
                    <div class="listing-group" id="starlink-group">
                        <input type="checkbox" id="starlink-toggle" checked>
                        <label for="starlink-toggle">Starlink</label>
                    </div>
                    <div class="listing-group" id="viasat-group">
                        <input type="checkbox" id="viasat-toggle">
                        <label for="viasat-toggle">ViaSat</label>
                    </div>
                </div>
            </div>
        </div>
        <!-- Additional content can go here if needed -->
    </div>

    <!-- Bootstrap JS Bundle (includes Popper) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Mapbox GL JS -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.13.0/mapbox-gl.js"></script>
    <!-- Include Turf.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script>
        // At the top, define the default zoom level
        const defaultZoomLevelOnLoad = 4;

        // Set your Mapbox access token
        mapboxgl.accessToken = 'pk.eyJ1IjoiczhtYXRodXIiLCJhIjoiY2xzbHl1Zjg0MGZpdjJrcGVpa2pkbG0wNiJ9.rFDdt45Wd4s6a-RfqvAQiQ';

        // Initialize the Mapbox map
        const map = new mapboxgl.Map({
            container: 'map', // HTML container id
            style: 'mapbox://styles/mapbox/light-v11', // Map style
            center: [-98.5795, 39.8283], // Center on USA
            zoom: defaultZoomLevelOnLoad, // Use the default zoom level from variable,
            attributionControl: false
        });
        map.addControl(new mapboxgl.AttributionControl({
            customAttribution: 'Powered by Fastah™ API with public data from AWS, Azure, SpaceX, and ViaSat'
        }))

        // Define the layers with properties
        const layers = [
            {
                id: 'aws',
                name: 'AWS',
                color: '#e74c3c',
                downloadUrl: 'https://space.us-east-1.aws.api.getfastah.com/cloud/aws?format=geojson',
                symbolName: 'aws-marker',
                markerImageUrl: 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/Amazon_Web_Services_Logo.svg/320px-Amazon_Web_Services_Logo.svg.png',
                markerSize: 0.1,
                iconOffset: [30, -30]  // Default offset for AWS icons
            },
            {
                id: 'azure',
                name: 'Azure',
                color: '#3498db',
                downloadUrl: 'https://space.us-east-1.aws.api.getfastah.com/cloud/azure?format=geojson',
                symbolName: 'azure-marker',
                markerImageUrl: 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/Microsoft_Azure.svg/240px-Microsoft_Azure.svg.png',
                markerSize: 0.1,
                iconOffset: [-30, 30]  // Default offset for Azure icons
            },
            {
                id: 'starlink',
                name: 'Starlink',
                color: '#2ecc71',
                downloadUrl: './gen/latest-feeds/starlink/samples.json',
                symbolName: 'starlink-marker',
                markerImageUrl: 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/Starlink_Logo.svg/320px-Starlink_Logo.svg.png',
                markerSize: 0.1,
                iconOffset: [-60, 60]  // Default offset for Starlink icons
            },
            {
                id: 'viasat',
                name: 'ViaSat',
                color: '#f1c40f',
                downloadUrl: './gen/latest-feeds/viasat/samples.json',
                symbolName: 'viasat-marker',
                markerImageUrl: 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/Viasat.svg/320px-Viasat.svg.png',
                markerSize: 0.2,
                iconOffset: [200, -200]  // Default offset for ViaSat icons
            }
        ];

        map.on('load', function () {

            function addLayerWithDataNonVisible(layer, data) {
                let iconImage = layer.symbolName;
                if (layer.id === 'aws') {
                    iconImage = [
                        'case',
                        ['==', ['get', 'type'], 'GroundStation'],
                        'aws-marker-groundstation',
                        layer.symbolName
                    ];
                }
                
                let iconOffsetExpr;
                if (layer.id === 'aws') {
                    // For AWS: use a case expression for a GroundStation special offset, otherwise use the default
                    iconOffsetExpr = [
                        'case',
                        ['==', ['get', 'type'], 'GroundStation'],
                        ["literal", [500, 500]],
                        ["literal", layer.iconOffset || [0, 0]]
                    ];
                } else {
                    // For azure, starlink, and viasat: use the literal offset from the layer definition
                    iconOffsetExpr = ["literal", layer.iconOffset || [0, 0]];
                }
                
                const baseLayout = {
                    'icon-image': iconImage,
                    'icon-size': layer.markerSize,
                    'icon-allow-overlap': true,
                    'visibility': 'none',
                    'icon-offset': iconOffsetExpr
                };
                
                map.addLayer({
                    'id': layer.id,
                    'type': 'symbol',
                    'source': {
                        'type': 'geojson',
                        'data': data
                    },
                    'layout': baseLayout
                });
            }

            function loadMarkerImage(layer) {
                return new Promise((resolve, reject) => {
                    if (layer.markerImageUrl) {
                        map.loadImage(layer.markerImageUrl, (error, image) => {
                            if (error) {
                                console.error('Error loading marker image for ' + layer.id, error);
                                reject(error);
                            } else {
                                map.addImage(layer.symbolName, image);
                                resolve();
                            }
                        });
                    } else {
                        resolve();
                    }
                });
            }

            // Load custom marker image for AWS GroundStation
            map.loadImage('../static/Icon-AWS-GroundStation.png', (error, image) => {
                if (error) {
                    console.error('Error loading AWS GroundStation marker image:', error);
                } else {
                    map.addImage('aws-marker-groundstation', image);
                }
            });

            Promise.all(layers.map(loadMarkerImage))
                .then(() => {
                    layers.forEach(function (layer) {
                        if (layer.id === 'aws' || layer.id === 'azure') {
                            fetch(layer.downloadUrl, {
                                headers: {
                                    'X-API-Key': 'NKEdnwRSyxreD4Xswg6jaVVxqt0tr3G90uPMpurh'
                                }
                            })
                            .then(response => response.json())
                            .then(data => {
                                addLayerWithDataNonVisible(layer, data);
                                // Optionally, you can call the update function here for each layer:
                                if (layer.id === 'aws') updateAWSFilter();
                                if (layer.id === 'azure') updateAzureFilter();
                            })
                            .catch(err => console.error('Error fetching ' + layer.id + ' data:', err));
                        } else {
                            addLayerWithDataNonVisible(layer, layer.downloadUrl);
                        }
                    });
                    // Alternatively, if you want to initialize the filters after the forEach loop,
                    // add a delayed call to ensure all layers have been added:
                    setTimeout(() => {
                        if (map.getLayer("aws")) updateAWSFilter();
                        if (map.getLayer("azure")) updateAzureFilter();
                        if (map.getLayer("starlink")) updateStarlinkLayer();
                    }, 2000);
                })
                .catch(err => {
                    console.error('Error loading marker images:', err);
                });

            // Add click handlers for AWS and Azure layers to display popups with metadata
            map.on('click', 'aws', function(e) {
                const feature = e.features[0];
                if (!feature) return;
                const coordinates = feature.geometry.coordinates.slice();
                const popupContent = `
                    <div style="font-family: Arial, sans-serif; font-size: 12px; color: #333;">
                        <strong>AWS ${feature.properties.type}</strong><br>
                        <span>${feature.properties.display_name || 'No display name available'}</span>
                    </div>`;
                new mapboxgl.Popup()
                    .setLngLat(coordinates)
                    .setHTML(popupContent)
                    .addTo(map);
            });

            map.on('click', 'azure', function(e) {
                const feature = e.features[0];
                if (!feature) return;
                const coordinates = feature.geometry.coordinates.slice();
                const popupContent = `
                    <div style="font-family: Arial, sans-serif; font-size: 12px; color: #333;">
                        <strong>Azure ${feature.properties.type}</strong><br>
                        <span>${feature.properties.display_name || 'No display name available'}</span>
                    </div>`;
                new mapboxgl.Popup()
                    .setLngLat(coordinates)
                    .setHTML(popupContent)
                    .addTo(map);
            });

            // Change the cursor to a pointer when hovering over AWS and Azure features
            map.on('mouseenter', 'aws', function() {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'aws', function() {
                map.getCanvas().style.cursor = '';
            });
            map.on('mouseenter', 'azure', function() {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'azure', function() {
                map.getCanvas().style.cursor = '';
            });

            // Coordinates: [longitude, latitude]
            const honolulu = [-157.8581, 21.3099];
            const boston = [-71.05, 42.35];

            // Create a Turf lineString using great circle (round earth) method
            const route = turf.greatCircle(turf.point(honolulu), turf.point(boston), {
                properties: { name: "Honolulu to Paris" },
              });

            // Calculate the total distance of the route in miles
            const totalDistance = turf.length(route, {units: 'miles'});
            console.log("Total route distance (miles):", totalDistance);

            // Generate points along the route at 1000-mile increments
            const segmentPoints = [];
            for (let i = 0; i <= totalDistance; i += 1000) {
                const pt = turf.along(route, i, {units: 'miles'});
                segmentPoints.push(pt);
            }

            // Convert the segment points into a GeoJSON FeatureCollection
            const segmentsGeoJSON = turf.featureCollection(segmentPoints);

            // Once the map loads, add the full route and the segment markers
            map.addSource('route', {
                type: 'geojson',
                data: route
            });
            map.addLayer({
                id: 'route-line',
                type: 'line',
                source: 'route',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': '#ff0000',
                    'line-width': 4,
                    'line-opacity': 0.75
                }
            });

            // Add the segment points as a source and circle layer
            map.addSource('route-segments', {
                type: 'geojson',
                data: segmentsGeoJSON
            });
            map.addLayer({
                id: 'segments-circles',
                type: 'circle',
                source: 'route-segments',
                paint: {
                    'circle-radius': 6,
                    'circle-color': '#0000ff',
                    'circle-stroke-width': 1,
                    'circle-stroke-color': '#ffffff'
                }
            });

            // Split the route into 1000 km segments
            const routeChunks = turf.lineChunk(route, 1000, {units: 'kilometers'});
            console.log("Number of 1000-km segments:", routeChunks.features.length);

            // Add the segmented red line as a source and layer
            map.addSource('route-chunks', {
                type: 'geojson',
                data: routeChunks
            });
            map.addLayer({
                id: 'route-chunks-layer',
                type: 'line',
                source: 'route-chunks',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                // Optionally use a dash array to emphasize the segmentation
                paint: {
                    'line-color': '#ff0000',
                    'line-width': 4,
                    'line-dasharray': [2, 4]
                }
            });

            map.loadImage('./static/marker-icons/airport.png', (error, image) => {
                if (error) {
                    console.error('Error loading plane image:', error);
                }
            });

            // Compute midpoints along each segment of the route
            const segmentMidpoints = [];
            routeChunks.features.forEach(segment => {
                const segLength = turf.length(segment, {units: 'kilometers'});
                const midPoint = turf.along(segment, segLength / 2, {units: 'kilometers'});
                segmentMidpoints.push(midPoint);
            });

            // Compute the initial bearing (if at least 2 midpoints exist, else default to 0)
            let initialBearing = 0;
            if (segmentMidpoints.length > 1) {
                initialBearing = turf.bearing(segmentMidpoints[0], segmentMidpoints[1]);
            }

            // Declare currentSegment only once here
            let currentSegment = 0;

            // Create the airplane feature with its initial orientation from the first segment 
            const planeFeature = {
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: segmentMidpoints[0].geometry.coordinates
                },
                properties: {
                    rotation: initialBearing
                }
            };

            map.addSource('plane', {
                type: 'geojson',
                data: planeFeature
            });
            map.addLayer({
                id: 'plane-layer',
                type: 'symbol',
                source: 'plane',
                layout: {
                    'icon-image': 'airport',
                    'icon-size': 4.0,
                    'icon-rotate': ['get', 'rotation'],
                    'icon-rotation-alignment': 'map',
                    'icon-allow-overlap': true
                }
            });

            // We'll store the interval ID so that we can stop the animation.
            let flightIntervalId = null;

            // Define a central delay value (in milliseconds) for viewing each segment
            const viewDelay = 5000; // 5 seconds

            function startFlightAnimation() {
              if (flightIntervalId === null) {
                // Define a recursive function for the animation loop
                function animateSegment() {
                  let nextIndex = currentSegment + 1;
                  // Stop the animation if reaching the last segment
                  if (nextIndex >= segmentMidpoints.length) {
                    stopFlightAnimation();
                    return;
                  }

                  const currentPos = segmentMidpoints[currentSegment];
                  const nextPos = segmentMidpoints[nextIndex];
                  // Calculate the bearing between the current and next points
                  const bearing = turf.bearing(currentPos, nextPos);

                  // Update the plane feature with the new coordinates and rotation
                  planeFeature.geometry.coordinates = nextPos.geometry.coordinates;
                  planeFeature.properties.rotation = bearing;
                  map.getSource('plane').setData(planeFeature);

                  // Set zoom to 6 then pan to center on the new airplane position
                  map.setZoom(6);
                  map.panTo(nextPos.geometry.coordinates, { animate: true });

                  currentSegment = nextIndex;
                  // Wait viewDelay milliseconds AFTER panTo and zoom actions, then animate the next segment
                  flightIntervalId = setTimeout(animateSegment, viewDelay);
                }
                // Start the recursive animation
                animateSegment();
              }
            }

            function stopFlightAnimation() {
              if (flightIntervalId !== null) {
                clearInterval(flightIntervalId);
                flightIntervalId = null;
              }
            }

            function resetFlightAnimation() {
              stopFlightAnimation();
              // Reset the animation state to the first segment
              currentSegment = 0;
              planeFeature.geometry.coordinates = segmentMidpoints[0].geometry.coordinates;
              planeFeature.properties.rotation = 0;
              map.getSource('plane').setData(planeFeature);
              // Reset the zoom level to the default value and pan to the starting position
              map.setZoom(defaultZoomLevelOnLoad);
              map.panTo(segmentMidpoints[0].geometry.coordinates, { animate: true });
            }

            // Attach event listeners to the buttons
            document.getElementById('startFlight').addEventListener('click', startFlightAnimation);
            document.getElementById('stopFlight').addEventListener('click', stopFlightAnimation);
            document.getElementById('resetFlight').addEventListener('click', resetFlightAnimation);

            // Ensure the map resizes correctly when the window size changes
            window.addEventListener('resize', () => {
                map.resize();
            });

            // Toggle layer visibility based on checkbox state for all layers
            document.getElementById('aws-toggle').addEventListener('change', function() {
                const visibility = this.checked ? 'visible' : 'none';
                map.setLayoutProperty('aws', 'visibility', visibility);
                // Update only Regions and Local Zones automatically
                const isChecked = this.checked;
                document.getElementById('aws-regions').checked = isChecked;
                document.getElementById('aws-localzones').checked = isChecked;
                // Do not auto-toggle Ground Stations and Wavelength Zones.
                updateAWSFilter();
            });
            document.getElementById('azure-toggle').addEventListener('change', function() {
                const visibility = this.checked ? 'visible' : 'none';
                map.setLayoutProperty('azure', 'visibility', visibility);
            });
            document.getElementById('starlink-toggle').addEventListener('change', function() {
                const visibility = this.checked ? 'visible' : 'none';
                map.setLayoutProperty('starlink', 'visibility', visibility);
            });
            document.getElementById('viasat-toggle').addEventListener('change', function() {
                const visibility = this.checked ? 'visible' : 'none';
                map.setLayoutProperty('viasat', 'visibility', visibility);
            });

            // Function to update the AWS layer filter based on children checkboxes
            function updateAWSFilter() {
                const showRegion         = document.getElementById('aws-regions').checked;
                const showLocalZones     = document.getElementById('aws-localzones').checked;
                const showGroundStations = document.getElementById('aws-groundstations').checked;
                const showWavelengthZones= document.getElementById('aws-wavelengthzones').checked;
                
                const conditions = [];
                if (showRegion)         { conditions.push(["==", ["get", "type"], "Region"]); }
                if (showLocalZones)     { conditions.push(["==", ["get", "type"], "LocalZone"]); }
                if (showGroundStations) { conditions.push(["==", ["get", "type"], "GroundStation"]); }
                if (showWavelengthZones){ conditions.push(["==", ["get", "type"], "WavelengthZone"]); }

                if (conditions.length === 0) {
                    // if nothing is selected, set a filter that never passes and hide the layer:
                    map.setFilter("aws", ["==", ["get", "type"], ""]);
                    map.setLayoutProperty("aws", "visibility", "none");
                } else {
                    // Apply the filter and show the layer
                    const filter = conditions.length === 1 ? conditions[0] : ["any", ...conditions];
                    map.setFilter("aws", filter);
                    map.setLayoutProperty("aws", "visibility", "visible");
                }
            }

            // Also attach listeners on each AWS child so that toggling any of them updates the filter
            document.getElementById('aws-regions').addEventListener('change', updateAWSFilter);
            document.getElementById('aws-localzones').addEventListener('change', updateAWSFilter);
            document.getElementById('aws-groundstations').addEventListener('change', updateAWSFilter);
            document.getElementById('aws-wavelengthzones').addEventListener('change', updateAWSFilter);

            // Function to update the Azure layer filter based on its checkbox state
            function updateAzureFilter() {
                const azureToggle = document.getElementById('azure-toggle').checked;
                if (azureToggle) {
                    map.setFilter("azure", ["==", ["get", "type"], "Region"]);
                    map.setLayoutProperty("azure", "visibility", "visible");
                } else {
                    map.setFilter("azure", ["==", ["get", "type"], ""]);
                    map.setLayoutProperty("azure", "visibility", "none");
                }
            }

            // Attach listener for Azure toggle if not already attached
            document.getElementById('azure-toggle').addEventListener('change', updateAzureFilter);

            // Function to update Starlink layer visibility based on its checkbox
            function updateStarlinkLayer() {
                const starlinkToggle = document.getElementById('starlink-toggle').checked;
                if (starlinkToggle) {
                    map.setLayoutProperty("starlink", "visibility", "visible");
                } else {
                    map.setLayoutProperty("starlink", "visibility", "none");
                }
            }

            // Attach listener for starlink toggle
            document.getElementById('starlink-toggle').addEventListener('change', updateStarlinkLayer);

            // Initialize the filters after layers have been added.
            if (map.getLayer("aws")) {
                updateAWSFilter();
            }
            if (map.getLayer("azure")) {
                updateAzureFilter();
            }
        });
    </script>
</body>

</html>